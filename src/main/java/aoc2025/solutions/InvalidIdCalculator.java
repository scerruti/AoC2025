package aoc2025.solutions;

import java.util.HashSet;
import java.util.Set;

public class InvalidIdCalculator {

    /**
     * Calculates the sum of "invalid" IDs within a range using a GENERATOR approach.
     * * Definition: An "Invalid ID" is one that HAS a repeating pattern.
     * (e.g. 121212 is invalid. 123456 is valid).
     * * Efficiency: Instead of checking every number in the range (which could be billions),
     * we mathematically generate only the patterned numbers that fall within the range.
     * * @param start The starting number of the range (inclusive).
     * @param end   The ending number of the range (inclusive).
     * @return The sum of all unique numbers in the range that have a repeating pattern.
     */
    public static long sumInvalidIds(long start, long end) {
        Set<Long> uniqueInvalidIds = new HashSet<>();
        
        int startLen = getLength(start);
        int endLen = getLength(end);

        // Iterate through all possible number lengths in the range
        for (int totalLen = startLen; totalLen <= endLen; totalLen++) {
            
            // Find proper divisors for this length (potential pattern lengths)
            // We iterate d from 1 up to totalLen / 2
            for (int d = 1; d <= totalLen / 2; d++) {
                if (totalLen % d == 0) {
                    generatePatternsForLength(totalLen, d, start, end, uniqueInvalidIds);
                }
            }
        }

        long sum = 0;
        for (Long id : uniqueInvalidIds) {
            sum += id;
        }
        return sum;
    }

    /**
     * Generates numbers of 'totalLen' composed of repeating patterns of length 'patLen'.
     * Adds them to the set if they fall within [rangeStart, rangeEnd].
     * * Mathematical Logic:
     * A repeating number N is formed by a base pattern P repeated K times.
     * N = P * (10^(d*(k-1)) + ... + 10^d + 1)
     * Let Multiplier M = (10^(totalLen) - 1) / (10^patLen - 1)
     * Then N = P * M.
     * * We solve for P such that: rangeStart <= P * M <= rangeEnd
     */
    private static void generatePatternsForLength(int totalLen, int patLen, long rangeStart, long rangeEnd, Set<Long> results) {
        // 1. Calculate the Multiplier (M)
        // Example: totalLen=4, patLen=2. Multiplier = 101. (P=12 -> 1212)
        // M can be built by string concatenation or math. Math is safer for logic.
        long multiplier = 0;
        long shift = 1;
        // Build multiplier: 10101...
        for (int i = 0; i < totalLen / patLen; i++) {
            multiplier += shift;
            // shift becomes 10^patLen, then 10^(2*patLen), etc.
            // We need to multiply shift by 10^patLen safely.
            long step = (long) Math.pow(10, patLen);
            shift *= step; 
        }

        // 2. Determine bounds for the Base Pattern P
        // P must be a 'patLen' digit number.
        long minP = (long) Math.pow(10, patLen - 1);
        long maxP = (long) Math.pow(10, patLen) - 1;

        // 3. Constrain P based on the requested range [rangeStart, rangeEnd]
        // We need: rangeStart <= P * M  =>  P >= ceil(rangeStart / M)
        // We need: P * M <= rangeEnd    =>  P <= floor(rangeEnd / M)
        
        long startConstraint = (rangeStart + multiplier - 1) / multiplier; // Ceiling division
        long endConstraint = rangeEnd / multiplier;                        // Floor division

        // Intersect the intrinsic bounds (digits) with range bounds
        long effectiveStart = Math.max(minP, startConstraint);
        long effectiveEnd = Math.min(maxP, endConstraint);

        // 4. Generate and collect
        for (long p = effectiveStart; p <= effectiveEnd; p++) {
            results.add(p * multiplier);
        }
    }

    private static int getLength(long n) {
        if (n == 0) return 1;
        return (int) Math.log10(Math.abs(n)) + 1;
    }

    public static void main(String[] args) {
        // Test Case 1: Small range
        // Range 100-200.
        // Length 3. Divisors: 1. Pattern length 1.
        // Multiplier for len 3, pat 1: 111.
        // P is 1 digit (1-9).
        // Candidates: 1*111=111, 2*111=222...
        // In range 100-200: 111 is the only one.
        System.out.println("Sum 100-200: " + sumInvalidIds(100, 200)); 
        // Expected: 111

        // Test Case 2: Range overlapping patterns
        // Range 1210-1220.
        // 1212 is a pattern (12 repeated).
        System.out.println("Sum 1210-1220: " + sumInvalidIds(1210, 1220)); 
        // Expected: 1212

        // Test Case 3: The overlaps
        // 111111 (generated by '1', '11', '111'). Should be counted once.
        System.out.println("Sum 111110-111112: " + sumInvalidIds(111110, 111112));
        // Expected: 111111 (Counted once, sum = 111111)
        
        // Test Case 4: Performance (Large Range)
        // 1 to 100,000,000 (100 million).
        // Iterating would take ~100ms-500ms. Generating should be nearly instant.
        long t0 = System.nanoTime();
        long sum = sumInvalidIds(1, 100000000L);
        long t1 = System.nanoTime();
        System.out.println("Sum 1-100M: " + sum + " (Time: " + (t1 - t0) / 1000 + " us)");
    }
}
